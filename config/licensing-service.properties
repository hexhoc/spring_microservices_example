spring.profiles.active=dev

example.property= I AM THE DEFAULT

spring.jpa.hibernate.ddl-auto=validate
spring.jpa.database=POSTGRESQL
spring.jpa.show-sql = true
spring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
spring.database.driverClassName= org.postgresql.Driver
spring.datasource.platform=postgres
spring.datasource.testWhileIdle = true
spring.datasource.validationQuery = SELECT 1

server.port= 8180

management.endpoints.web.exposure.include=*
management.endpoints.enabled-by-default=true

spring.flyway.enabled=true


# Tells the Config Server to use this value as the symmetric key
encrypt.key=fje83Ki8403Iod87dne7Yjsl3THueh48jfuO9j4U2hf64Lo 

# Registers the IP address of the service rather than the server name.
# By default, Eureka registers the services that contact it by hostname. This works well
# in a server-based environment, where a service is assigned a DNS-backed hostname.
# However, in a container-based deployment (for example, Docker), containers are
# started with randomly generated hostnames and no DNS entries for the containers
eureka.instance.preferIpAddress = true
# Registers the service with Eureka
# Is the trigger to tell the organization and the licensing services to register with Eureka
eureka.client.registerWithEureka = true
# tells the Spring Eureka client to fetch a local copy of the #registry
# caches the registry locally instead of calling the Eureka service with each lookup
eureka.client.fetchRegistry = true
# Sets the location of the Eureka service.
eureka.client.serviceUrl.defaultZone = http://eurekaserver:8070/eureka/

keycloak.realm = spmia-realm
keycloak.auth-server-url = http://keycloak:8080/auth
keycloak.ssl-required = external
keycloak.resource = ostock
keycloak.credentials.secret = V4BXdHSnhjRl4N0uJhPdGDFhF0N2ZdY1
keycloak.use-resource-role-mappings = true
keycloak.bearer-only = true

# NOTICE! inboundOrgChanges it is our custom channel
# The Spring Cloud Stream configuration for consuming  a message
# Maps the input channel to the orgChangeTopic queue
spring.cloud.stream.bindings.inboundOrgChanges.destination= orgChangeTopic
spring.cloud.stream.bindings.inboundOrgChanges.content-type= application/json
# The group property defines the name of the consumer group that will consume the message.
# The concept of a consumer group is this: we can have multiple services with each
#service having multiple instances listening to the same message queue. We want each
#unique service to process a copy of a message, but we only want one service instance
#within a group of service instances to consume and process a message. The group
#property identifies the consumer group that the service belongs to.

# The message is consumed by exactly ONLY ONE licensing service instance because they all share the same consumer group (licensing).
spring.cloud.stream.bindings.inboundOrgChanges.group= licensingGroup


#Redis configuration
redis.server = redis
redis.port = 6379